import os
from pathlib import Path
from typing import List, Tuple

from langchain import FAISS
from langchain.agents import Tool
from langchain.chains import ConversationalRetrievalChain
from langchain.chains.conversational_retrieval.base import BaseConversationalRetrievalChain
from langchain.embeddings import OpenAIEmbeddings
from langchain.llms.base import BaseLLM
from langchain.memory import ReadOnlySharedMemory
from langchain.schema import AIMessage, Document, HumanMessage
from langchain.text_splitter import CharacterTextSplitter

from spork.utils import NumberedLinesTextLoader


def run_retrieval_chain_with_sources_format(
    chain: BaseConversationalRetrievalChain, q: str
) -> str:
    result = chain(q)
    return f'Answer: {result["answer"]}.\n\n Sources: {result["source_documents"]}'


class CodebaseOracleToolBuilder:
    def __init__(self, codebase_path: str, llm: BaseLLM, memory: ReadOnlySharedMemory):
        self.codebase_path = codebase_path
        self.llm = llm
        self.memory = memory
        # check that the codebase is a git repo
        assert (
            Path(self.codebase_path).joinpath(".git").exists()
        ), "Codebase path must be a git repo"
        # we make chain into a mutable state variable, because we need to refresh it occasionally
        self._needs_refresh = True

    def build(self) -> Tool:
        return Tool(
            name="Codebase Oracle tool",
            func=lambda q: run_retrieval_chain_with_sources_format(self._get_chain(), q),
            description="Useful for when you need to answer specific questions about the contents of the repository"
            " you're working on, like how does a given function work or where is a particular variable set,"
            " or what is in a file or where a file is. Input should be a fully formed question.",
        )

    def _build_chain(self):
        docs = []
        embeddings = OpenAIEmbeddings()
        for dirpath, dirnames, filenames in os.walk(self.codebase_path):
            if not self._is_excluded(dirpath):
                directory_document = Document(
                    page_content=f"Directory: path={dirpath}; inner_directories={dirnames}; files={filenames}",
                    metadata={"source": dirpath},
                )
                docs.append(directory_document)
                for file in filenames:
                    if not self._is_excluded(os.path.join(dirpath, file)):
                        try:
                            loader = NumberedLinesTextLoader(os.path.join(dirpath, file))
                            docs.extend(loader.load())
                        except Exception as e:
                            print(dirpath, file, e)
        text_splitter = CharacterTextSplitter(chunk_size=2000, chunk_overlap=200)
        texts = text_splitter.split_documents(docs)
        docsearch = FAISS.from_documents(texts, embeddings)
        self._chain = ConversationalRetrievalChain.from_llm(
            llm=self.llm,
            retriever=docsearch.as_retriever(seatch_type="mmr"),
            memory=self.memory,
            return_source_documents=True,
            get_chat_history=self._get_chat_history,
        )

    def _get_chat_history(self, chat_history: List[Tuple[HumanMessage, AIMessage]]) -> str:
        buffer = ""
        for human_m, ai_m in chat_history:
            human = "Human: " + str(human_m)
            ai = "Assistant: " + str(ai_m)
            buffer += "\n" + "\n".join([human, ai])
        return buffer

    def _get_chain(self):
        if self._needs_refresh:
            self._build_chain()
            self._needs_refresh = False
        return self._chain

    def refresh_callback(self):
        # we give this to the editor so that it can tell the codebase oracle to refresh its chain with new codebase content
        self._needs_refresh = True

    def _is_excluded(self, path):
        exclusions = [
            ".git",
            ".gitignore",
            ".gitattributes",
            ".gitmodules",
            "__pycache__",
            ".idea",
            "build",
            "local_env",
            "dist",
            "chroma",
            "egg",  # exclude a few common directories in the
            ".git",  # root of the project
            ".hg",
            ".mypy_cache",
            ".tox",
            ".venv",
            "_build",
            "buck-out",
            "random",
        ]
        for exclusion in exclusions:
            if exclusion in path:
                return True
        return False
